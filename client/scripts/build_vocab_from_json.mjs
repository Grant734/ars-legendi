// scripts/build_vocab_from_json.mjs
// Usage (from client/): node scripts/build_vocab_from_json.mjs
// Writes:
//   - src/vocab/data/nouns.js       (export const nounsByDeclension = {...})
//   - src/vocab/data/verbs.js       (export const verbsByConjugation = {...})
//   - src/vocab/data/adjectives.js  (export const adjectivesByDeclension = {...})

import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname  = path.dirname(__filename);

// ----- Paths (relative to client/)
const RAW    = path.join(__dirname, "data_raw");               // scripts/data_raw
const OUT_N  = path.resolve("src/vocab/data/nouns.js");
const OUT_V  = path.resolve("src/vocab/data/verbs.js");
const OUT_A  = path.resolve("src/vocab/data/adjectives.js");

// ----- Helpers
function readJSON(p) {
  const raw = fs.readFileSync(p, "utf8");

  // Common “invisible” issues
  const trimmed = raw.replace(/^\uFEFF/, "").trim(); // remove BOM + whitespace
  if (!trimmed) {
    throw new Error(`Empty JSON file: ${p}`);
  }

  try {
    return JSON.parse(trimmed);
  } catch (e) {
    // Print a helpful snippet so you can spot truncation
    const tail = trimmed.slice(Math.max(0, trimmed.length - 220));
    console.error(`\n❌ JSON parse failed in: ${p}`);
    console.error(`   File length: ${trimmed.length} chars`);
    console.error("   Last ~220 chars:");
    console.error(tail);
    console.error("");
    throw e;
  }
}

function ensureDirFor(filePath) {
  fs.mkdirSync(path.dirname(filePath), { recursive: true });
}

function listRawFiles() {
  if (!fs.existsSync(RAW)) {
    throw new Error(`RAW dir not found: ${RAW}`);
  }
  return fs.readdirSync(RAW).filter(f => f.endsWith(".json"));
}

function groupBy(arr, key) {
  const g = {};
  for (const it of arr) {
    const k = String(it[key]);
    if (!g[k]) g[k] = [];
    g[k].push(it);
  }
  return g;
}

function writeModule(dest, exportName, grouped) {
  const sortedKeys = Object.keys(grouped).sort((a,b) => {
    const na = Number(a), nb = Number(b);
    if (!Number.isNaN(na) && !Number.isNaN(nb)) return na - nb; // numeric keys first
    if (a === "irregular") return 1;
    if (b === "irregular") return -1;
    return a.localeCompare(b);
  });

  const body = sortedKeys.map(k => {
    const arr = grouped[k].map(w => ({
      lemma: w.lemma,
      english: w.english,
      entry: w.entry,
      ...(w.declension ? { declension: w.declension } : {}),
      ...(w.conjugation ? { conjugation: w.conjugation } : {}),
      ...(w.category ? { category: w.category } : {}),
      distractors: (w.distractors || []).slice(0, 3),
    }));
    return `  ${isNaN(Number(k)) ? JSON.stringify(k) : k}: ${JSON.stringify(arr, null, 2)}`;
  }).join(",\n");

  const code = `// AUTO-GENERATED by scripts/build_vocab_from_json.mjs
// Do not edit by hand. Edit scripts/data_raw/*.json and rebuild.

export const ${exportName} = {
${body}
};
`;
  ensureDirFor(dest);
  fs.writeFileSync(dest, code, "utf8");
  console.log("Wrote", dest);
}

// ----- Loaders
function loadNouns() {
  const files = listRawFiles();

  let paths = [];
  if (files.includes("nouns.json")) {
    paths = [path.join(RAW, "nouns.json")];
  } else {
    const byPattern = [
      ...files.filter(f => /^nouns_decl[1-5]\.json$/i.test(f)).sort(),
      ...files.filter(f => /^declension[1-5]\.json$/i.test(f)).sort(),
    ];
    paths = byPattern.map(f => path.join(RAW, f));
  }

  if (paths.length === 0) {
    console.warn("⚠️  No noun files found. nounsByDeclension will be empty.");
    return [];
  }

  const out = [];
  for (const p of paths) {
    const arr = readJSON(p);
    if (!Array.isArray(arr)) throw new Error(`Expected array in ${p}`);
    out.push(...arr);
  }
  console.log(`Loaded nouns from ${paths.length} file(s):`, paths.map(p => path.basename(p)).join(", "));
  return out;
}

function loadVerbs() {
  const files = listRawFiles();

  let paths = [];
  if (files.includes("verbs.json")) {
    paths = [path.join(RAW, "verbs.json")];
  } else {
    const conj = files.filter(f => /^conjugation[1-4]\.json$/i.test(f)).sort();
    const irr  = files.includes("irregular.json") ? ["irregular.json"] : [];
    paths = [...conj, ...irr].map(f => path.join(RAW, f));
  }

  if (paths.length === 0) {
    console.warn("⚠️  No verb files found. verbsByConjugation will be empty.");
    return [];
  }

  const out = [];
  for (const p of paths) {
    const arr = readJSON(p);
    if (!Array.isArray(arr)) throw new Error(`Expected array in ${p}`);
    out.push(...arr);
  }
  console.log(`Loaded verbs from ${paths.length} file(s):`, paths.map(p => path.basename(p)).join(", "));
  return out;
}

function loadAdjectives() {
  const files = listRawFiles();

  let paths = [];
  if (files.includes("adjectives.json")) {
    paths = [path.join(RAW, "adjectives.json")];
  } else {
    const byPattern = [
      ...files.filter(f => /^adjectives[_-]?12\.json$/i.test(f)),
      ...files.filter(f => /^adjectives[_-]?3\.json$/i.test(f)),
      ...files.filter(f => /^adjectives12\.json$/i.test(f)),
      ...files.filter(f => /^adjectives3\.json$/i.test(f)),
      ...files.filter(f => /^adjective[_-]?12\.json$/i.test(f)),
      ...files.filter(f => /^adjective[_-]?3\.json$/i.test(f)),
    ];

    // de-dupe
    const seen = new Set();
    const uniq = [];
    for (const f of byPattern) {
      const fl = f.toLowerCase();
      if (seen.has(fl)) continue;
      seen.add(fl);
      uniq.push(f);
    }
    paths = uniq.map(f => path.join(RAW, f));
  }

  if (paths.length === 0) {
    console.warn("⚠️  No adjective files found. adjectivesByDeclension will be empty.");
    return [];
  }

  const out = [];
  for (const p of paths) {
    const arr = readJSON(p);
    if (!Array.isArray(arr)) throw new Error(`Expected array in ${p}`);
    out.push(...arr);
  }

  console.log(`Loaded adjectives from ${paths.length} file(s):`, paths.map(p => path.basename(p)).join(", "));
  return out;
}

function main() {
  const nouns = loadNouns();
  const verbs = loadVerbs();
  const adjs  = loadAdjectives();

  const gN = groupBy(nouns, "declension");    // "1".."5"
  const gV = groupBy(verbs, "conjugation");   // "1".."4" or "irregular"
  const gA = groupBy(adjs,  "declension");    // "212" and "3"

  writeModule(OUT_N, "nounsByDeclension", gN);
  writeModule(OUT_V, "verbsByConjugation", gV);
  writeModule(OUT_A, "adjectivesByDeclension", gA);

  const nCount = Object.values(gN).reduce((a,b)=>a+b.length,0);
  const vCount = Object.values(gV).reduce((a,b)=>a+b.length,0);
  const aCount = Object.values(gA).reduce((a,b)=>a+b.length,0);

  console.log(`✅ Build complete: ${nCount} nouns, ${vCount} verbs, ${aCount} adjectives.`);
}

main();
